name: Two-stage match
description: |
  This charter demonstrates how to perform a multi-stage match. Multi-stage matches can be used when
  there is more than one type of grouping possible (i.e. different fields involved in the group-by).

  In this example all data comes from a single file. We have four types of transaction, TYP1...TYP4.
  TYP1 and TYP2 should be brought together into matches.
  TYP3 and TYP4 should be brought together into matches.
version: 1637208553000
instructions:
  - source_data:
      file_patterns: ['2-stage\.csv']

      # Disable field prefixes. Without this, all the fields would be prefixed with '2-stage.' for
      # example '2-stage.Amount_1'. Instead, by suppressing them we can use 'Amount_1' instead.
      # This is useful when there is no chance of different columns having the same header (due to
      # multiple files being involved).
      field_prefixes: false

  # After sourcing the data our loaded memory grid looks like this (the description column from the
  # example file has been ommitted): -
  #
  # Type Amount_1 Amount_2 Date_1        Date_2
  # TYP1   100.00   ------ 1623110400000 -------------
  # TYP2   ------   100.00 1623110400000 -------------
  # TYP1   100.00   ------ 1633110400000 -------------
  # TYP2   ------   100.00 1633110400000 -------------
  # TYP3   250.00   ------ 1643110400000 -------------
  # TYP4   250.00   ------ ------------- 1643110400000

  # Stage 1

  # We will be forming groups of TYP1 and TYP2 by grouping the data by the Date_1 column.
  # However, when grouping TYP1 and TYP2 records we don't want to bring in TYP3 records into
  # the groups by mistake (which also has a value in the Date_1 column).
  #
  # One way around this is to use the filter instruction (covered in it's own example). Another
  # way is to project a new date column to group on, but only populate it from TYP1 and TYP2
  # records. And perform two match instructions, one using one projected date and another using
  # the second projected date.
  #
  # Whilst a filter would be much simpler to solve this particular problem, multi-stage matches
  # are a useful tool with some larger files that contain a variety of transaction types in them.

  - project:
      column: 'Stage1_Date'
      as_type: DATE
      from: record["Date_1"]
      when: record["type"] == "TYP1" or record["type"] == "TYP2"

  # Our data will now look like this: -
  #
  # Stage1_Date   Type Amount_1 Amount_2 Date_1        Date_2
  # 1623110400000 TYP1   100.00   ------ 1623110400000 -------------
  # 1623110400000 TYP2   ------   100.00 1623110400000 -------------
  # 1633110400000 TYP1   100.00   ------ 1633110400000 -------------
  # 1633110400000 TYP2   ------   100.00 1633110400000 -------------
  # ------------- TYP3   250.00   ------ 1643110400000 -------------
  # ------------- TYP4   250.00   ------ ------------- 1643110400000

  - merge_columns:
      from: ['Amount_1', 'Amount_2']
      into: AMOUNT

  # This gives us something to NET the records together with for both stages 1 and 2.
  # Our data will now look like this: -
  #
  # AMOUNT Stage1_Date   Type Amount_1 Amount_2 Date_1        Date_2
  # 100.00 1623110400000 TYP1   100.00   ------ 1623110400000 -------------
  # 100.00 1623110400000 TYP2   ------   100.00 1623110400000 -------------
  # 100.00 1633110400000 TYP1   100.00   ------ 1633110400000 -------------
  # 100.00 1633110400000 TYP2   ------   100.00 1633110400000 -------------
  # 250.00 ------------- TYP3   250.00   ------ 1643110400000 -------------
  # 250.00 ------------- TYP4   250.00   ------ ------------- 1643110400000

  - match_groups:
      group_by: ['Stage1_Date']
      constraints:
        - nets_to_zero:
            column: AMOUNT
            lhs: record["Type"] == "TYP1"
            rhs: record["Type"] == "TYP2"

  # Our data will now look like this as TYP1 and TYP2 have passed the above match and constraints: -
  #
  # AMOUNT Stage1_Date   Type Amount_1 Amount_2 Date_1        Date_2
  # 250.00 ------------- TYP3   250.00   ------ 1643110400000 -------------
  # 250.00 ------------- TYP4   250.00   ------ ------------- 1643110400000

  # Stage 2

  - project:
      column: 'Stage2_Date'
      as_type: DATE
      from: record["Date_1"] or record["Date_2"]
      when: record["type"] == "TYP3" or record["type"] == "TYP4"

  # Our data will now look like this: -
  #
  # Stage2_Date   AMOUNT Stage1_Date   Type Amount_1 Amount_2 Date_1        Date_2
  # 1643110400000 250.00 ------------- TYP3   250.00   ------ 1643110400000 -------------
  # 1643110400000 250.00 ------------- TYP4   250.00   ------ ------------- 1643110400000

  - match_groups:
      group_by: ['Stage2_Date']
      constraints:
        - nets_to_zero:
            column: AMOUNT
            lhs: record["Type"] == "TYP3"
            rhs: record["Type"] == "TYP4"

  # This will match-off the TYP3 and TYP4 records leaving us with no un-matched data.