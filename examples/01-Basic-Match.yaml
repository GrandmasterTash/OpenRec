name: Basic Match
description: |
  This charter demonstrates how to set-up a basic match between a single invoice and one or more payments
  for that invoice. There no complexities in this match, a unique reference ('Ref') is present for both sets
  of data.

  TODO: Document qualified field names and how data is loaded into memory.

# TODO: Document that all waiting files must have a particular file format.
# TODO: Document that fields are case-sensitive.
version: 1
debug: true


matching:
  # TODO: Explain how the pattern works and how it allows unmatched files as well.
  source_files:
     # Notice '.*' appears twice in both patterns? The first occurrence is because all files presented to matching have a timestamp prefix in their filename. So the above patterns match all dates. The second occurrence is because, when a match job results in un-matched data, the original file is given a new format. For example:
    # 20220103_18400000_invoices.csv -> 20220103_18400000_invoices.unmatched.csv
     # So the second occurrence of '.*' allows files with or without the '.unmatched' portion of the filename to be processed.
    - pattern: .*01-invoices.*\.csv
      field_prefix: INV
    - pattern: .*01-payments.*\.csv
      field_prefix: PAY
  instructions:
    - merge:
        columns: ['INV.Amount', 'PAY.Amount']
        into: AMOUNT
    - merge:
        columns: ['INV.Ref', 'PAY.Ref']
        into: REF
    - group:
        by: ['REF']
        match_when:
          - nets_to_zero:
              column: AMOUNT
              lhs: record["META.prefix"] == "PAY"
              rhs: record["META.prefix"] == "INV"
